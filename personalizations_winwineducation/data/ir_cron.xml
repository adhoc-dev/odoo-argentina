<?xml version='1.0' encoding='UTF-8'?>
<odoo>
  <record id="personalizations_winwineducation.ir_cron_31_99a5610f" model="ir.cron">
    <field name="name">Notificar próximo cumpleaños</field>
    <field ref="hr.model_hr_employee" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">

time = datetime.date.today() + dateutil.relativedelta.relativedelta(days=3)
employees = env['hr.employee'].search([])
for i in employees:
    if i.birthday:
        day_month = i.birthday
        if time.day == day_month.day and time.month == day_month.month:
          activity_type = env['mail.activity.type'].search([('name', '=', 'Recordatorio')], limit=1)
          env['mail.activity'].with_context(allowed_company_ids=[i.company_id.id]).sudo().create({
            'activity_type_id': activity_type.id,
            'note': 'Se aproxima el cumpleaños de "%s". Es el día "%s".' % (i.name, i.birthday),
            'date_deadline': time,
            'res_id': i.id,
            'res_model_id': env['ir.model']._get('hr.employee').id,
            'user_id': 35
          })
</field>
    <field name="interval_number">1</field>
    <field name="interval_type">days</field>
    <field name="numbercall">-1</field>
    <field eval="True" name="doall"/>
  </record>
  <record id="notificar_inactividad_entrevistadores" model="ir.cron">
    <field name="name">Solicitudes - Notificar inactividad entrevistadores</field>
    <field ref="hr_recruitment.model_hr_applicant" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">
# busco solicitudes que esten en la etapa de entrevista
# necesito saber si esa fue la última etapa y cuanto hace que está en esa etapa
solicitudes = env['hr.applicant'].search([('stage_id','in',[2,3,6,12,13])])

#Estoy comparando que la fecha donde se pasó de etapa + 7 días sea igual al día de hoy
#Agrego .date() porque date_last_stage_update es un datetime y no es conveniente comparar fecha y hora. Me manejo con fechas solamente
for rec in solicitudes.filtered(lambda x: (x.date_last_stage_update + dateutil.relativedelta.relativedelta(days=7)).date() == datetime.date.today()):
  cv = rec.attachment_ids.filtered(lambda x:x.name)
  template_id = env['mail.template'].browse(55)
  entrevistador = rec.x_appraisal_ids.filtered(lambda e: e.x_applicant_stage_id.sequence == rec.stage_id.sequence).x_partner_id
  template_id.with_context(email_to = entrevistador.email, entrevistador = entrevistador.name).send_mail(rec.id, email_values={'attachment_ids': cv.ids}) #La plantilla corresponde al modelo candidato</field>
    <field name="interval_number">1</field>
    <field name="interval_type">days</field>
    <field name="numbercall">-1</field>
    <field eval="True" name="doall"/>
  </record>
  <record id="personalizations_winwineducation.ir_cron_33_e4b84deb" model="ir.cron">
    <field name="name">Actualizar etapa iniciativa / crm encuesta completada</field>
    <field ref="crm.model_crm_lead" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">

# env['crm.lead']
env['crm.lead'].search([('stage_id','=',4), ('response_id.state','=','done')]).write({'stage_id': 5 })


</field>
    <field name="interval_number">8</field>
    <field name="interval_type">minutes</field>
    <field name="numbercall">-1</field>
  </record>
  <record id="personalizations_winwineducation.ir_cron_34_dc200463" model="ir.cron">
    <field name="name">Notificaciones de cumpleaños</field>
    <field ref="hr.model_hr_employee" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">
def enviar_mails(nivel, directivos, empleados):
  template_directivos = env['mail.template'].browse(53)
  template_directivos.with_context(nivel = nivel, email_to = directivos, birthdays=', '.join(empleados.mapped('name'))).send_mail(empleados[0].id) #La plantilla corresponde al modelo candidato

def enviar_mails_cumpleanieros(empleados):
  template_empleado = env['mail.template'].browse(64)
  for emp in empleados:
    template_empleado.send_mail(emp.id)

empleados = env['hr.employee'].search([('birthday','ilike', '%-'+datetime.date.today().strftime('%m')+'-'+datetime.date.today().strftime('%d')),('department_id','!=',False)]) #Empleados que cumplen años, tengo que determinar si son de primaria o secundaria
if empleados:
  #mail a cada cumpleañero
  enviar_mails_cumpleanieros(empleados)
  for company in empleados.mapped('company_id'):
      #Mail para RRHH y cada empleado que deba ser notificado de los cumpleaños de su área
      for nivel in empleados.filtered(lambda x: x.company_id == company).mapped('department_id.name'):
        cumple = empleados.filtered(lambda x: x.company_id == company and nivel in x.department_id.name)
        #Para solucionar lo de primario y secundario se crea una etiqueta que tenga ese nombre y listo
        if cumple:
            enviar_mails(nivel, ', '.join(env['hr.employee'].search([('company_id.name','=',company.name),('category_ids.name','=',nivel),('work_email','!=',False)]).mapped('work_email')),cumple)
</field>
    <field name="interval_number">1</field>
    <field name="interval_type">days</field>
    <field name="numbercall">-1</field>
  </record>
  <record id="personalizations_winwineducation.ir_cron_35_4adefadc" model="ir.cron">
    <field name="name">Renuncias - Cambiar de etapa (WIP)</field>
    <field ref="hr_recruitment.model_hr_applicant" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">
env['hr.applicant'].search([('stage_id','=',12), ('response_id.state','=','done')]).write({'stage_id': 13 })


</field>
    <field eval="False" name="active"/>
    <field name="interval_number">12</field>
    <field name="interval_type">hours</field>
    <field name="numbercall">-1</field>
  </record>
  <record id="personalizations_winwineducation.ir_cron_37_8042b3e4" model="ir.cron">
    <field name="name">Conciliar facturas con cobros TuCuota</field>
    <field ref="account.model_account_move" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">

# en winwin generan los cobros de tu cuota antes de las facturas, por eso dejamos esta accion automatica para que intente conciliar siempre que haya facturas sin conciliar.
# no lo hacemos como accion automatica monitoreando campo "state" porque puede ser un poco problematica a nivel performance cuando procesen a todos los colegios
# (Sobre todo que la validación de facturas ya consume demasiado tiempo al validar en afip)
# buscamos todas las facturas generadas desde suscripciones a cobrar con tu cuota
for invoice in env['account.move'].search([('state', '=', 'posted'), ('invoice_payment_state', '=', 'not_paid'), ('invoice_line_ids.subscription_id.payment_token_id.acquirer_id.name', 'like', 'TuCuota')]):
    # obtenemos el token
    token = invoice.invoice_line_ids.mapped('subscription_id').filtered('payment_token_id').mapped('payment_token_id')
    if not token:
        continue
    token = token[0]
    # buscamos cobros ya realizado con ese token y que no esten conciliados
    move_line = env['account.move.line'].search([
        ('account_id.internal_type', '=', 'receivable'),
        ('partner_id', '=', invoice.commercial_partner_id.id),
        ('payment_id.payment_token_id', '=', token.id),
        ('amount_residual', '=', -invoice.amount_residual),
    ])
    # si hay mas de uno es algo raro, no conciliamos
    if len(move_line) != 1:
        continue
    # conciliamos
    lines = invoice.line_ids.filtered(lambda r: not r.reconciled and r.account_id.internal_type in ('payable', 'receivable'))
    (move_line + lines).reconcile()
</field>
    <field name="interval_number">1</field>
    <field name="interval_type">hours</field>
    <field name="numbercall">-1</field>
  </record>
<record id="personalizations_winwineducation.calcular_semaforo" model="ir.cron">
    <field name="name">Calcular Semaforo</field>
    <field ref="base.model_res_partner" name="model_id"/>
    <field name="state">code</field>
    <field name="binding_type">action</field>
    <field name="code">
domain = [('account_id.internal_type', '=', 'receivable'), ('full_reconcile_id', '=', False), ('amount_residual','!=', 0)]
all_partner_ids = []
to_date = datetime.date.today()
# first_date_of_year = to_date.replace(day=1, month=1)

# vamos buscando en peridos de tiempo hacia atras, desde hace un mes hasta hoy, luego desde hace dos meses hasta hace un mes, etc...
# y vamos a ir escribiendo el valor de semaforo correspondiente.
# al hacerlo de esta manera solo hay 4 search y 4 write
for months, semaforo in [(1, '1'), (2, '2'), (3, '3'), (999, '999')]:
    from_date = to_date - dateutil.relativedelta.relativedelta(months=months)
    # si se queiere que solo se tengan en cuenta deudas de año actual
    # res = env['account.move.line'].read_group(domain + [('first_date_of_year', '&gt;=', first_date_of_year), ('date_maturity', '&gt;=', from_date)
    #, ('date_maturity', '&lt;', to_date)], ['partner_id'], 'partner_id')
    res = env['account.move.line'].read_group(domain + [('date_maturity', '&gt;=', from_date), ('date_maturity', '&lt;', to_date)], ['partner_id'], 'partner_id')
    to_date = from_date
    partner_ids = [x['partner_id'][0] for x in res]
    env['res.partner'].browse(partner_ids).write({'semaforo': semaforo})
    all_partner_ids += partner_ids

env['res.partner'].search([('id', 'not in', all_partner_ids), ('semaforo', '!=', False)]).write({'semaforo': False})

</field>
    <field name="interval_number">1</field>
    <field name="interval_type">days</field>
    <field name="numbercall">-1</field>
</record>
</odoo>
