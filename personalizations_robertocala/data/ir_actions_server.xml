<?xml version='1.0' encoding='UTF-8'?>
<odoo>
  <record model="ir.actions.server" id="personalizations_robertocala.ir_act_server_1025">
    <field name="name">[invoice_operations] Generar Facturas </field>
    <field ref="account.model_account_move" name="model_id"/>
    <field name="state">code</field>
    <field ref="account.model_account_move" name="crud_model_id"/>
    <field name="code"><![CDATA[object = record
object = record
# CONFIG
Distribuidora_ID = 1
German_Cala_ID = 4
Iva_0_cala_ID = 5
Iva_0_german_cala_ID = 103


def move_invoice(invoice, company_id):
    """
    Moves the invoice to another company
    """
    invoice = invoice.with_context(force_company=company_id)

    # Al escribir la compania limpiamos tmb las posicioens fiscales por constraint de que no puede haber compania y posicion de otra cia. Luego total el onchange termina asignando la compania que corresponda
    invoice.write({'fiscal_position_id': False})
    journal = invoice.sudo().with_context(default_company_id=company_id, force_company = company_id, default_type=invoice.type)._get_default_journal().id
    # Ugly hack para recalcular available_jorunal_document_type y journal_document_type_id y evitar constrain
    if invoice.journal_id:
        invoice = invoice.sudo()
        invoice.write({'company_id': company_id, 'fiscal_position_id': False, 'journal_id': journal})
    if invoice.l10n_latam_document_type_id:
        invoice.write({ 
            'l10n_latam_document_type_id': False,
            'journal_id': journal,
            'company_id': company_id,
            'fiscal_position_id': False
        })
    # Property fields to maintain
    property_fields = {'invoice_payment_term_id': invoice.invoice_payment_term_id.id}
    invoice._onchange_partner_id()
    invoice.write(property_fields)
    for line in invoice.invoice_line_ids.with_context(check_move_validity=False):
        taxes = line._get_computed_taxes()
        if taxes and line.move_id.fiscal_position_id:
            taxes = line.move_id.fiscal_position_id.map_tax(taxes, partner=line.partner_id)
        line.write({
            'account_id' : line._get_computed_account().id,
            'tax_ids' :  [(6,0, taxes.ids)],
        })
        line._onchange_price_subtotal()
        line._onchange_balance()
        line._onchange_mark_recompute_taxes()
    invoice._onchange_invoice_line_ids()
    return invoice



def generate_child_invoice(invoice):
    """
    Generates invoices based on aux_percentage
    Returns the created invoices
    """
    def get_aux_perc(line):
        if line.product_id.x_operation_type == '50-50':
            percentage = 50.0
        elif line.product_id.x_operation_type == 'roberto_cala':
            percentage = 100.0
        elif line.product_id.x_operation_type == 'distribuidora':
            percentage = 0.0
        else:
            percentage = False
        # si es iva 10,5 devolver 50
        # si es iva 21 devolver es 100
        # si es iva 0 devolver es 0
        return percentage

    new_lines = env['account.move.line']
    
    for line in invoice.invoice_line_ids.with_context(check_move_validity=False):
        # get aux_perc limited by product config
        line_aux_perc = get_aux_perc(line)
        if not line_aux_perc:
            continue
        round_precision = 0
        # calc move quantities (rounded)
        new_quantity = round(
            line.quantity * line_aux_perc / 100.0, round_precision)
        if not new_quantity:
            continue
        new_line = line.copy({'quantity': new_quantity})
        # hacemos esto por que al duplicar la linea se duplica el precio unitario
        if new_line.price_unit != line.price_unit:
            new_line.write({'price_unit' : line.price_unit})
        new_line.write({'sale_line_ids': [(6, 0, line.sale_line_ids.ids)]
        })
        new_lines += new_line
        line.write({'quantity': line.quantity - new_quantity,
                    # 'uom_id': line.product_id.uom_id.id,
                    'tax_ids': [(6, 0, [Iva_0_cala_ID])],
                    })
        line._onchange_price_subtotal()
        line._onchange_balance()
        line._onchange_mark_recompute_taxes()
        
        if abs(line.quantity) < 0.0001:
            line.unlink()
    
    # Solo generamos en Aux si alguna linea podia moverse
    if new_lines:
        
        new_invoice = invoice.with_context(check_move_validity=False).copy()
        new_invoice.invoice_line_ids.unlink()
        new_lines.with_context(check_move_validity=False).write({'move_id': new_invoice.id})
        new_invoice._onchange_invoice_line_ids()
        new_invoice = move_invoice(new_invoice, German_Cala_ID)
    else:
        new_invoice = invoice
    # Si no queda nada en la factura original, se elimina
    if not invoice.invoice_line_ids:
        invoice.unlink()

    # return generated invoices
    return new_invoice


def main():
    invoices = object
    invoices += generate_child_invoice(invoices)
    actions = env.ref('account.action_move_out_invoice_type')
    action_read = actions.read()[0]
    action_read['domain'] = [('id', 'in', invoices.ids)]
    return action_read
        
action = main()]]></field>
  </record>
  <record model="ir.actions.server" id="personalizations_robertocala.ir_act_server_1273">
    <field name="name">Uptade prices (de producto a ail)</field>
    <field ref="account.model_account_move" name="model_id"/>
    <field name="state">code</field>
    <field name="code"><![CDATA[

for line in record.invoice_line_ids:
    price_unit = line.product_id.standard_price
    if (
        price_unit and
            record.currency_id != line.product_id.currency_id):
        price_unit = line.product_id.currency_id.compute(
            price_unit, record.currency_id)
    if (
            price_unit and line.uom_id and
            line.product_id.uom_id != line.uom_id):
        price_unit = line.product_id.uom_id._compute_price(price_unit,
            to_unit=line.uom_id)
    line.write({'price_unit': price_unit})
    line._onchange_price_subtotal()
    # recomputamos impuestos
    line._onchange_mark_recompute_taxes()
    #line.write({'exclude_from_invoice_tab:False})
    line._onchange_balance()
    invoice = line.mapped('move_id')
    invoice._recompute_dynamic_lines(recompute_all_taxes=True)
    invoice._onchange_invoice_line_ids()





]]></field>
  </record>
</odoo>
